#include<iostream>
#include<cstdio>
#include<algorithm>
#include<stack>
#include<queue>
#define N 10005
#define M 100005
using namespace std;
int n, m, tot = 0, time1 = 0 , ans = 0;
int head[N], val[N], ins[N], low[N], dfn[N], bel[N], head2[N], inSum[N] , dp[N];
struct edge { int to, next; }e1[M], e2[M];
stack<int>sta;
queue<int>q;
void add_edge(int x, int y) { e1[++tot].to = y, e1[tot].next = head[x], head[x] = tot; }
void add_edge2(int x, int y) { e2[++tot].to = y, e2[tot].next = head2[x], head2[x] = tot; }
void tarjan(int nowNode)
{
    low[nowNode] = dfn[nowNode] = ++time1;
    sta.push(nowNode), ins[nowNode] = 1;
    for (int i = head[nowNode]; i != 0; i = e1[i].next) {
        int nextNode = e1[i].to;
        if (!dfn[nextNode]) tarjan(nextNode), low[nowNode] = min(low[nowNode], low[nextNode]);
        else if (ins[nextNode]) low[nowNode] = min(low[nowNode], low[nextNode]);
    }
    if (low[nowNode] == dfn[nowNode]) {
        while (sta.top() != nowNode) {
            bel[sta.top()] = nowNode;  // 缩点，记录sta.top()属于nowNode所处的强连通分量中
                                       // 或者可以利用tot2++; while(){……bel[sta.top()] = tot2}来记录新图中的点，这样新图中的点的编号为1-tot2
            ins[sta.top()] = 0, sta.pop();
        }
        bel[nowNode] = nowNode;
        ins[nowNode] = 0, sta.pop();
    }
}
void createNewMap()
{
    for (int nowNode = 1; nowNode <= n; nowNode++) {
        for (int i = head[nowNode]; i != 0; i = e1[i].next) {
            int nextNode = e1[i].to;
            int x = bel[nowNode], y = bel[nextNode];
            if (x == y) continue;
            add_edge2(x, y);
            inSum[y]++;
        }
    }
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> val[i];
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        add_edge(x, y);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    createNewMap();  // 建立新的图，存到e2
    for (int i = 1; i <= n; i++) {
        if (bel[i] != i) val[bel[i]] += val[i];  // 更新新图的val值
        if (bel[i] == i && inSum[i] == 0) q.push(i);  // 记录新图中存在哪几个编号的点
        dp[bel[i]] = max(dp[bel[i]], val[bel[i]]);
    }
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = head2[x]; i != 0; i = e2[i].next) {
            int y = e2[i].to;
            dp[y] = max(dp[y], dp[x] + val[y]);
            if (--inSum[y] == 0) q.push(y);
        }
        ans = max(ans, dp[x]);
    }  // 拓扑排序+dp
    cout << ans;
    return 0;
}
