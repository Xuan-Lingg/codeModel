#include<iostream>
#include<cstdio>
#include<algorithm>
#include<stack>
#include<vector>
#define N 500005
#define M 2000005
using namespace std;
struct edge { int to, next; }e[M * 2];
int n, m, tot = 0, time1 = 0, tot1 = 0;
int head[N], dfn[N], low[N], ins[N];
stack<int>sta;
vector<int>ans[N];
void add_edge(int x, int y) {
    e[++tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
}
void tarjan(int nowNode, int fa) {  // 通过记录fa处理同一条边回去的情况
    dfn[nowNode] = low[nowNode] = ++time1;
    sta.push(nowNode);
    ins[nowNode] = 1;
    for (int i = head[nowNode]; i != 0; i = e[i].next) {
        int nextNode = e[i].to;
        if (nextNode == fa) { fa = 0; continue; }  // 第一次遇到指向fa时默认是同一条边，更新fa为0，跳过
        if (!dfn[nextNode]) { tarjan(nextNode, nowNode); low[nowNode] = min(low[nowNode], low[nextNode]); }
        else if (ins[nextNode]) { low[nowNode] = min(low[nowNode], dfn[nextNode]); }  // 注意此处为dfn[nextNode]
    }
    if (dfn[nowNode] == low[nowNode]) {
        tot1++;
        while(sta.top() != nowNode)
        {
            ans[tot1].push_back(sta.top());
            ins[sta.top()] = 0;
            sta.pop();
        }
        ans[tot1].push_back(sta.top());
        ins[sta.top()] = 0;
        sta.pop();
    }  // tarjan操作
}
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        add_edge(x, y), add_edge(y, x);  // 存无向图
    }
    for(int i = 1 ; i <= n ; i++)
        if(!dfn[i]) tarjan(i , i);
    cout << tot1 << endl;
    for(int i = 1 ; i <= tot1 ; i++){
        cout << ans[i].size() << " ";
        for (int j = 0; j < ans[i].size(); j++) cout << ans[i][j] << " ";
        cout << endl;
    }
    return 0;
}
