#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 100005
  using namespace std;
int n , m;
long long a[N];
struct tree{ int left , right; long long pre , add;} tree[N*8];
void build_tree(int nowNode , int l , int r)
{
    tree[nowNode].left = l , tree[nowNode].right = r;
    if(l == r){tree[nowNode].pre = a[l]; return ;}
    int mid = (l + r) / 2;
    build_tree(nowNode * 2 , l , mid);
    build_tree(nowNode * 2 + 1 , mid + 1 , r);
    tree[nowNode].pre = tree[nowNode * 2].pre + tree[nowNode * 2 + 1].pre;
    return ;
}
void spread(int nowNode)
{
    if(!tree[nowNode].add) return ;
    tree[nowNode * 2].pre += (long long)(tree[nowNode * 2].right - tree[nowNode * 2].left + 1) * tree[nowNode].add;
    tree[nowNode * 2 + 1].pre += (long long)(tree[nowNode * 2 + 1].right - tree[nowNode * 2 + 1].left + 1) * tree[nowNode].add;
    tree[nowNode * 2].add += tree[nowNode].add , tree[nowNode * 2 + 1].add += tree[nowNode].add;
    tree[nowNode].add = 0;  // 当前结点标记清零，更新子节点标记
}  // 下传标记
void add(int nowNode , int l , int r , long long k)
{
    
    if(tree[nowNode].left >= l && tree[nowNode].right <= r){  // 整个区间都需要更新
        tree[nowNode].pre += (long long)(tree[nowNode].right - tree[nowNode].left + 1) * k;
        tree[nowNode].add += k;  // 更新当前区间的pre和标记
        return ;
    }
    spread(nowNode);
    int mid = (tree[nowNode].left + tree[nowNode].right) / 2;
    if(l <= mid) add(nowNode * 2 , l , r , k);  // 如果当前节点的左区间部分在【l，r】中，更新左区间
    if(r > mid) add(nowNode * 2 + 1, l , r , k);
    tree[nowNode].pre = tree[nowNode * 2].pre + tree[nowNode * 2 + 1].pre;  // 更新子区间后更新当前区间
}
long long ask(int nowNode , int l , int r)
{
    if(tree[nowNode].left >= l && tree[nowNode].right <= r) return tree[nowNode].pre;
    spread(nowNode);
    int mid = (tree[nowNode].left + tree[nowNode].right) / 2;
    long long val = 0;
    if(mid >= l) val += ask(nowNode * 2 , l , r);
    if(r > mid) val += ask(nowNode * 2 + 1 , l , r);
    return val;
}
int main()
{
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i++) cin >> a[i];
    build_tree(1 , 1 , n);
    while(m > 0){
        m--;
        int p , x , y;
        long long k;
        cin >> p;
        if(p == 1) { cin >> x >> y >> k; add(1 , x , y , k);}
        if(p == 2) { cin >> x >> y; cout << ask(1 , x , y) << endl;}
    }
    return 0;
}
